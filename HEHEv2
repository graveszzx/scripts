local runService = game:GetService("RunService")
local players = game:GetService("Players")
local replicatedStorage = game:GetService("ReplicatedStorage")
local aiZones = workspace.AiZones
local Workspace = workspace

-- // Variáveis Globais
local localPlayer = players.LocalPlayer
local camera = workspace.CurrentCamera
local bullet -- Referência ao módulo

-- // Configuração Silent Aim
local silentAim = {
	Enabled = true,
	WallCheck = true,
	HitPart = "Head",
	Prediction = true,
	Fov = {
		Visible = true,
		Radius = 150
	},
    IgnoreFriends = { "mielsfangirl" },
    RemoveSpread = true,
    RemoveWeight = false,
    InstantBullet = true
}

-- // Configuração Terrain
local terrainConfig = {
    RemoveGrass = true
}

-- // Desenhos
local drawings = {}
local espDrawings = {}

local function draw(drawingType, properties, isEsp)
	local drawing = Drawing.new(drawingType)
    if isEsp then
        table.insert(espDrawings, drawing)
    else
        table.insert(drawings, drawing)
    end
	for index, value in properties do 
		drawing[index] = value
	end
	return drawing
end

-- // Funções auxiliares
local function isAlive(player)
	return player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") 
        and player.Character:FindFirstChild("Humanoid") 
        and player.Character.Humanoid.Health > 0
end

local function isVisible(origin, target, ...)
	local ignore = { camera, ... }
	if isAlive(localPlayer) then 
		ignore[#ignore + 1] = localPlayer.Character
	end
	
	local hit = workspace:FindPartOnRayWithIgnoreList(Ray.new(origin, target.Position - origin), ignore, false, true)
	return hit and hit:IsDescendantOf(target.Parent)
end

local function getAi()
	local ai = {}
	for _,v in aiZones:GetChildren() do
		for _, character in v:GetChildren() do
			ai[#ai + 1] = character
		end
	end
	return ai
end

-- // Cálculo balístico
local function solveQuadratic(A, B, C)
    local discriminant = B^2 - 4*A*C
    if discriminant < 0 then return nil, nil end
    local discRoot = math.sqrt(discriminant)
    local root1 = (-B - discRoot) / (2*A)
    local root2 = (-B + discRoot) / (2*A)
    return root1, root2
end

local function getBallisticFlightTime(direction, gravity, projectileSpeed)
    local root1, root2 = solveQuadratic(
        gravity:Dot(gravity) / 4,
        gravity:Dot(direction) - projectileSpeed^2,
        direction:Dot(direction)
    )
    if root1 and root2 then
        if root1 > 0 and root1 < root2 then
            return math.sqrt(root1)
        elseif root2 > 0 and root2 < root1 then
            return math.sqrt(root2)
        end
    end
    return 0
end

local function projectileDrop(origin, target, projectileSpeed, acceleration)
	local gravity = Vector3.new() + Vector3.yAxis * (acceleration * 2)
	local time = getBallisticFlightTime(target - origin, gravity, projectileSpeed)
	return 0.5 * gravity * time^2
end

local function predict(target, origin, projectileSpeed, acceleration)
	local gravity = Vector3.new() + Vector3.yAxis * (acceleration * 2)
	local time = getBallisticFlightTime(target.Position - origin, gravity, projectileSpeed)
	return target.Position + (target.Velocity * time)
end

-- // Target
local function getTarget(...)
	local cloestHitPart, closestDistance = nil, silentAim.Fov.Radius
    local cloestRootPart = nil
	local originPosition = camera.CFrame.Position

	local characters = getAi()
	for _, player in players:GetPlayers() do
		if player ~= localPlayer and isAlive(player) then
            local ignore = false
            for _, name in ipairs(silentAim.IgnoreFriends) do
                if player.Name == name then
                    ignore = true
                    break
                end
            end
            if not ignore then
			    table.insert(characters, player.Character)
            end
		end
	end

	for _, character in ipairs(characters) do 
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then continue end
		local hitPart = character:FindFirstChild(silentAim.HitPart)
		if not hitPart then continue end
		
        local isTargetVisible = not silentAim.WallCheck or isVisible(originPosition, hitPart, ...)
        if silentAim.WallCheck and not isTargetVisible then continue end
		
		local screenPosition, onScreen = camera:WorldToViewportPoint(hitPart.Position)
		if not onScreen then continue end

		local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - camera.ViewportSize/2).Magnitude
		if distance < closestDistance then
			closestDistance = distance
			cloestHitPart = hitPart
            cloestRootPart = rootPart
		end
	end

	return cloestHitPart, cloestRootPart
end

-- // Setup Dependencies
local function setupDependencies()
    local success, newBullet = pcall(require, replicatedStorage.Modules.FPS.Bullet)
    if not success then 
        warn("Could't Re-Require Bullet Module. Silent Aim may not work.")
        return false
    end
    bullet = newBullet
    localPlayer = players.LocalPlayer
    camera = workspace.CurrentCamera
    return true
end

-- // Namecall Hook
local function setupNamecallHook()
    if getgenv()._delta_namecall then return end
    local old
    old = hookmetamethod(game, "__namecall", function(self, ...)
        local method = getnamecallmethod()
        local args = { ... }
        if not checkcaller() then
            if method == "GetAttribute" and args[1] then
                local attr = tostring(args[1])
                if attr == "AccuracyDeviation" and silentAim.RemoveSpread then
                    return 0
                elseif (attr == "Recoil" or attr == "Weight") and silentAim.RemoveWeight then
                    return 0
                end
            end
        end
        return old(self, ...)
    end)
    getgenv()._delta_namecall = true
end

-- // Hook Silent Aim
local function setupHook()
    local oldBullet
    oldBullet = hookfunction(bullet.CreateBullet, function(idk, model, model2, model3, aimPart, idk2, ammoType, tick, recoilPattern)
        if not bullet or not silentAim.Enabled then
            return oldBullet(idk, model, model2, model3, aimPart, idk2, ammoType, tick, recoilPattern)
        end
        local target, _ = getTarget(model, model2, model3, aimPart)
        if target then
            local bulletData = replicatedStorage.AmmoTypes:FindFirstChild(ammoType)
            if bulletData then
                local acceleration = bulletData:GetAttribute("ProjectileDrop")
                local projectileSpeed = bulletData:GetAttribute("MuzzleVelocity")
                bulletData:SetAttribute("Drag", 0)
                if silentAim.RemoveSpread then
                    bulletData:SetAttribute("AccuracyDeviation", 0)
                end
                if silentAim.InstantBullet then
                    projectileSpeed = 9e9
                end
                local targetPosition = (silentAim.Prediction and predict(target, aimPart.Position, projectileSpeed, acceleration)) or target.Position
                local vertical = projectileDrop(aimPart.Position, targetPosition, projectileSpeed, acceleration)
                aimPart = { CFrame = CFrame.new(aimPart.Position, targetPosition + vertical) }
            end
        end
        return oldBullet(idk, model, model2, model3, aimPart, idk2, ammoType, tick, recoilPattern)
    end)
end

-- // Remove Grass
runService.RenderStepped:Connect(function()
    if terrainConfig.RemoveGrass then
        sethiddenproperty(Workspace.Terrain, "Decoration", false)
    else
        sethiddenproperty(Workspace.Terrain, "Decoration", true)
    end
end)

-- // FOV CIRCLE
do
    local Circle = draw("Circle", { Visible = false, Filled = false, NumSides = 1000, Color = Color3.fromRGB(255,255,255), Thickness = 1 })
    runService.RenderStepped:Connect(function()
        if camera and silentAim.Fov.Visible then
            Circle.Visible = true
            Circle.Position = camera.ViewportSize / 2
            Circle.Radius = silentAim.Fov.Radius
        else
            Circle.Visible = false
        end
    end)
end

-- // ESP
local Tracer = draw("Line", { Visible = false, Color = Color3.fromRGB(255,255,255), Thickness = 1.5 }, true)
local TextInfo = draw("Text", { Visible = false, Size = 16, Font = 2, Outline = true, Color = Color3.fromRGB(255,255,255) }, true)

runService.RenderStepped:Connect(function()
    local hitPart, rootPart = getTarget()
    if rootPart then
        local targetPosition = rootPart.Position
        local screenPos, onScreen = camera:WorldToViewportPoint(targetPosition)
        if onScreen then
            Tracer.Visible = true
            Tracer.From = camera.ViewportSize / 2
            Tracer.To = Vector2.new(screenPos.X, screenPos.Y)
            local isVisibleToCamera = isVisible(camera.CFrame.Position, rootPart)
            local distance = math.floor((localPlayer.Character.HumanoidRootPart.Position - targetPosition).Magnitude)
            local name = rootPart.Parent:FindFirstChildOfClass("Humanoid") and rootPart.Parent.Name or "NPC"
            local visibilityText = isVisibleToCamera and "VISÍVEL" or "NÃO VISÍVEL"
            local visibilityColor = isVisibleToCamera and Color3.fromRGB(0,255,0) or Color3.fromRGB(255,0,0)
            TextInfo.Visible = true
            TextInfo.Position = Vector2.new(screenPos.X, screenPos.Y - 20)
            TextInfo.Text = string.format("%s\n[%s | %dm]", name, visibilityText, distance)
            TextInfo.Color = visibilityColor
            Tracer.Color = visibilityColor
        else
            Tracer.Visible = false
            TextInfo.Visible = false
        end
    else
        Tracer.Visible = false
        TextInfo.Visible = false
    end
end)

-- // Persistência
if setupDependencies() then
    if not hookfunction then 
        return players.LocalPlayer:Kick("Executor Dosen't Have hookfunction.")
    end
    setupNamecallHook()
    setupHook()
    print("Silent Aim + RemoveSpread + RemoveWeight + InstantBullet carregado!")
else
    return players.LocalPlayer:Kick("Could't initialize dependencies. Script stopped.")
end

players.LocalPlayer.CharacterAdded:Connect(function()
    setupDependencies()
    print("Silent Aim: Player reapareceu. Variáveis atualizadas.")
end)

-- // Toggle de remover grama
-- Para ativar/desativar:
-- terrainConfig.RemoveGrass = true  -- remove
-- terrainConfig.RemoveGrass = false -- restaura
