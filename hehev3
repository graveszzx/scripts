local runService = game:GetService("RunService");
local players = game:GetService("Players");
local replicatedStorage = game:GetService("ReplicatedStorage");
local workspace = game:GetService("Workspace");
local aiZones = workspace:WaitForChild("AiZones");

-- // HJTLE E INOCENTE
pcall(function()
	sethiddenproperty(workspace.Terrain, "Decoration", false);
	print("[Silent Aim] Grass e decorações do terreno removidas automaticamente.");
end);

-- // Variáveis Globais
local localPlayer = players.LocalPlayer;
local camera = workspace.CurrentCamera;
local bullet; -- Referência ao módulo

-- // Configuração
local silentAim = {
	Enabled = true,
	WallCheck = false,
	HitPart = "Head",
	Prediction = true,
	Fov = {
		Visible = true,
		Radius = 450
	},
    IgnoreFriends = { "kakagpla" } -- lista de amigos a ignorar
};

-- // Desenhos
local drawings = {};
local espDrawings = {}; 

local function draw(drawingType, properties, isEsp)
	local drawing = Drawing.new(drawingType);
    if isEsp then
        table.insert(espDrawings, drawing);
    else
        table.insert(drawings, drawing);
    end
	for index, value in properties do 
		drawing[index] = value;
	end;
	return drawing;
end;

local function isAlive(player)
	return player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") 
        and player.Character:FindFirstChild("Humanoid") 
        and player.Character.Humanoid.Health > 0;
end;

local function isVisible(origin, target, ...)
	local ignore = { camera, ... };
	if isAlive(localPlayer) then 
		ignore[#ignore + 1] = localPlayer.Character;
	end;
	
	local hit = workspace:FindPartOnRayWithIgnoreList(Ray.new(origin, target.Position - origin), ignore, false, true);
	return hit and hit:IsDescendantOf(target.Parent);
end;

local function getAi()
	local ai = {};
	for _,v in aiZones:GetChildren() do
		for _, character in v:GetChildren() do
			ai[#ai + 1] = character;
		end;
	end;
	return ai;
end;

-- // Cálculo Balístico
local function solveQuadratic(A, B, C)
    local discriminant = B^2 - 4*A*C;
    if discriminant < 0 then return nil, nil end
    local discRoot = math.sqrt(discriminant);
    local root1 = (-B - discRoot) / (2*A);
    local root2 = (-B + discRoot) / (2*A);
    return root1, root2;
end;

local function getBallisticFlightTime(direction, gravity, projectileSpeed)
    local root1, root2 = solveQuadratic(
        gravity:Dot(gravity) / 4,
        gravity:Dot(direction) - projectileSpeed^2,
        direction:Dot(direction)
    );

    if root1 and root2 then
        if root1 > 0 and root1 < root2 then
            return math.sqrt(root1);
        elseif root2 > 0 and root2 < root1 then
            return math.sqrt(root2);
        end;
    end;
    return 0;
end;

local function projectileDrop(origin, target, projectileSpeed, acceleration)
	local gravity = Vector3.new() + Vector3.yAxis * (acceleration * 2);
	local time = getBallisticFlightTime(target - origin, gravity, projectileSpeed);
	return 0.5 * gravity * time^2;
end;

local function predict(target, origin, projectileSpeed, acceleration)
	local gravity = Vector3.new() + Vector3.yAxis * (acceleration * 2);
	local time = getBallisticFlightTime(target.Position - origin, gravity, projectileSpeed);
	return target.Position + (target.Velocity * time); 
end;

-- // Target
local function getTarget(...)
	local cloestHitPart, closestDistance = nil, silentAim.Fov.Radius;
    local cloestRootPart = nil;
	local originPosition = camera.CFrame.Position;

	local characters = getAi();
	for _, player in players:GetPlayers() do
		if player ~= localPlayer and isAlive(player) then
            -- ignora se o jogador for da lista de amigos
            local ignore = false
            for _, name in ipairs(silentAim.IgnoreFriends) do
                if player.Name == name then
                    ignore = true
                    break
                end
            end
            if not ignore then
			    table.insert(characters, player.Character);
            end
		end
	end

	for _, character in ipairs(characters) do 
        local rootPart = character:FindFirstChild("HumanoidRootPart");
        if not rootPart then continue end

		local hitPart = character:FindFirstChild(silentAim.HitPart);
		if not hitPart then continue end
		
        local isTargetVisible = not silentAim.WallCheck or isVisible(originPosition, hitPart, ...);
        
		if silentAim.WallCheck and not isTargetVisible then 
			continue;
		end;
		
		local screenPosition, onScreen = camera:WorldToViewportPoint(hitPart.Position);
		if not onScreen then 
			continue;
		end;

		local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - camera.ViewportSize/2).Magnitude;
		if distance < closestDistance then
			closestDistance = distance;
			cloestHitPart = hitPart;
            cloestRootPart = rootPart;
		end
	end

	return cloestHitPart, cloestRootPart;
end;

-- // Setup
local function setupDependencies()
    local success, newBullet = pcall(require, replicatedStorage.Modules.FPS.Bullet);
    if not success then 
        warn("Could't Re-Require Bullet Module. Silent Aim may not work.");
        return false;
    end
    bullet = newBullet; 

    localPlayer = players.LocalPlayer;
    camera = workspace.CurrentCamera;
    
    return true;
end

-- // Hook Silent Aim
local function setupHook()
    local oldBullet; 
    oldBullet = hookfunction(bullet.CreateBullet, function(idk, model, model2, model3, aimPart, idk2, ammoType, tick, recoilPattern)
        
        if not bullet then return end 

        if not silentAim.Enabled then
            return oldBullet(idk, model, model2, model3, aimPart, idk2, ammoType, tick, recoilPattern);
        end

        local target, _ = getTarget(model, model2, model3, aimPart);
        
        if target then
            local bulletData = replicatedStorage.AmmoTypes:FindFirstChild(ammoType);
            if not bulletData then
                return oldBullet(idk, model, model2, model3, aimPart, idk2, ammoType, tick, recoilPattern);
            end

            local acceleration = bulletData:GetAttribute("ProjectileDrop");
            local projectileSpeed = bulletData:GetAttribute("MuzzleVelocity");

            bulletData:SetAttribute("Drag", 0); 

            local targetPosition = (silentAim.Prediction and predict(target, aimPart.Position, projectileSpeed, acceleration)) or (target.Position);
            local vertical = projectileDrop(aimPart.Position, targetPosition, projectileSpeed, acceleration);
            
            local new = { 
                ["CFrame"] = CFrame.new(aimPart.Position, targetPosition + vertical)
            };

            return oldBullet(idk, model, model2, model3, new, idk2, ammoType, tick, recoilPattern);
        end;

        return oldBullet(idk, model, model2, model3, aimPart, idk2, ammoType, tick, recoilPattern);
    end);
end

-- // FOV CIRCLE
do
    local Circle = draw("Circle", {
        Visible = false, 
        Filled = false, 
        NumSides = 1000, 
        Color = Color3.fromRGB(255, 255 ,255), 
        Thickness = 1
    });
    
    runService.RenderStepped:Connect(function()
        if camera and silentAim.Fov.Visible then
            Circle.Visible = true;
            Circle.Position = camera.ViewportSize / 2;
            Circle.Radius = silentAim.Fov.Radius;
        else
            Circle.Visible = false;
        end
    end);
end

-- // ESP (Tracer + Texto)
local Tracer = draw("Line", { Visible = false, Color = Color3.fromRGB(255, 255, 255), Thickness = 1.5 }, true);
local TextInfo = draw("Text", { Visible = false, Size = 16, Font = 2, Outline = true, Color = Color3.fromRGB(255, 255, 255) }, true);

runService.RenderStepped:Connect(function()
    if not camera then 
        Tracer.Visible = false;
        TextInfo.Visible = false;
        return 
    end

    local hitPart, rootPart = getTarget(); 

    if rootPart then
        local targetPosition = rootPart.Position;
        local screenPos, onScreen = camera:WorldToViewportPoint(targetPosition);
        
        if onScreen then
            Tracer.Visible = true;
            Tracer.From = camera.ViewportSize / 2;
            Tracer.To = Vector2.new(screenPos.X, screenPos.Y);

            local isVisibleToCamera = isVisible(camera.CFrame.Position, rootPart);
            local distance = math.floor((localPlayer.Character.HumanoidRootPart.Position - targetPosition).Magnitude);
            local name = rootPart.Parent:FindFirstChildOfClass("Humanoid") and rootPart.Parent.Name or "NPC";
            local visibilityText = isVisibleToCamera and "VISÍVEL" or "NÃO VISÍVEL";
            local visibilityColor = isVisibleToCamera and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0);

            TextInfo.Visible = true;
            TextInfo.Position = Vector2.new(screenPos.X, screenPos.Y - 20);
            TextInfo.Text = string.format("%s\n[%s | %dm]", name, visibilityText, distance);
            TextInfo.Color = visibilityColor;
            Tracer.Color = visibilityColor;
        else
            Tracer.Visible = false;
            TextInfo.Visible = false;
        end
    else
        Tracer.Visible = false;
        TextInfo.Visible = false;
    end
end)
